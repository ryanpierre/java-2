# Demo 

Today we'll implement the stories:

```
As a user
So that I can see what others are saying
I want to see all tweets in reverse chronological order
```

```
As a user
So that I can better appreciate the context of a twitter
I want to see the time at which it was posted
```

Notes:

- I noticed that we called findAll() on the TweetRepository class but that method is not declared.
- When I looked into this, I found that because this interface extends CrudRepository, it already implements a bunch of features I need such as findAll. When I tried to figure out why findById needed to be extended, I found a similar answer about Services... Services are basically where we put business logic so its not in the controller.
-  I think I want to use a Service pattern ... the @Service baked into spring seems to be a strong indication it's a preferred pattern
-  The default findById is in the repository. I'm going to move it to a service
-  The internet says I should use Optional<Tweet>, but the original example uses List<Tweet> as the return type, so I'll stick with that
-  After more research, I realized that Service is only useful if your methods plan on going well beyond the scope of the basic CrudRepository, which ours don't so I revert.
-  I then looked up how to sort with spring data and I have two options: one is by naming methods and this automagically generates things depending on what words I choose, the other is by adding a sort to the findAll() like `findAll(Sort.by(Sort.Direction.ASC, "seatNumber"))`
-  I'm going to try the magic first.
-  **First I'll TDD adding the created_at field to the Tweet class, I start by adding the date to the first test, which will make it fail**
-  I looked up how to add a date field in spring here. looks like there are some @Temporal types to help me !
    ```java
    @Temporal(TemporalType.TIMESTAMP)
    Date creationDateTime;
    ```
- **I immediately realize in order to test this properly I'll need a mock date. In order to use a mock date, I'll need a common interface too. I don't start by buolding the interface though, I'll extract that later so I can focus on TDD**
    ```java
    // DateFactory
    package tech.makers.twitter;

    import java.time.LocalDate;

    public class DateFactory implements IDateFactory {
        public LocalDate create() {
            return LocalDate.now();
        }
    }


    // IDateFactory
   package tech.makers.twitter;

    import java.time.LocalDate;

    public interface IDateFactory {
       LocalDate create();
    }
    ```

    I don't need to TDD my DateFactory. I couldn't. There isn't any way I could do it without mocking date, which defeats the purpose.

- I realized this was all wrong when there is already a mechanism in place to mock dates. I'm just uzing the Clock and Zone classes to fix time at a particular time for new Dates

- I found this helpful when working with JPA https://www.baeldung.com/jpa-entities

- This was also helpful in a way for something to consider in the future https://www.baeldung.com/selenium-webdriver-page-object

## New TDD Tutorial
- I want to add a Date, but specific date constructors are deprecated in Java 11, so I'm just going to use the "New way" of doing this
- I start by adding a setup block for my test so that I have some mock dates I can use in all my tests. I'm stubbing the LocalDateTime now() method to always return a fixed clock. What I'll do is dependency inject this clock in order to mock time.

```java
    private Clock mockClock;

    @BeforeEach
    void setup() {
        String instantExpected = "2021-01-01T00:00:00Z";
        ZoneId zoneId = ZoneId.systemDefault();
        mockClock = Clock.fixed(Instant.parse(instantExpected), zoneId);
    }

    @Test
    void testConstructs() {
        Tweet subject = new Tweet("Hello, world!", mockClock);
        assertEquals("Hello, world!", subject.getBody());
        assertNull(subject.getId());
        assertEquals(LocalDateTime.now(mockClock), subject.getDate());
    }
...
}
```
- I then start trying to make the test pass by changing the tweet class. I add the new constuctor, and implement the method to return `LocalDateTime.now(clock)`. I'll need to add a getDate accessor too.

```java
    private LocalDateTime createdAt;

    protected Tweet() {}

    public Tweet(String body) {
        this.body = body;
        this.createdAt = LocalDateTime.now(Clock.systemUTC());
    }

    public Tweet(String body, Clock clock) {
        this.body = body;
        this.createdAt = LocalDateTime.now(clock);
    }
```

- By default, column and table names are autogenerated. You can use the @Table and @Column annotations to specify more constraints to a column or table. I added a 140 character limit to demo as well as specifying a column definition for my createdAt column

```java
     @Column(name="body", length=140)
    private String body;

    @Column(name = "created_at", columnDefinition = "TIMESTAMP")
    private LocalDateTime createdAt;
```

- This also automatically created this column for me ... or maybe it already existed ? Not sure but didn't need to do anything in my database for this to see the created_at field.

To see this in action, I need to restart my server by killing the tab in the run section of intelliJ and restarting. Then, you'll see: Hibernate: alter table if exists tweet add column created_at TIMESTAMP

- Make sure to add spring.jpa.hibernate.ddl-auto=create-drop to your test application.properties to keep things clean :)

- Now that my feature test is passing, let's add the time stamp to the page. We want to make it look pretty :D 

- I added a date to the template. I used the temporals library since I am working with the LocalDateTime object. If I were using a regular Date, this wouldnt work !

I add my assertion to the existing test in the format I want my date to look:
`assertThat(driver.findElement(By.tagName("body")).getText()).contains("2021-01-01 at 1:00PM");`

```java
<span th:text="${#temporals.formatISO(tweet.createdAt)}"></span>
```